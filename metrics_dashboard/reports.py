"""Report generation and formatting."""

from datetime import datetime

import httpx

from metrics_dashboard.dora import format_rating, get_overall_rating
from metrics_dashboard.models import DoraMetrics, MetricsReport


def generate_report(
    current_metrics: DoraMetrics,
    previous_metrics: DoraMetrics | None = None,
) -> MetricsReport:
    """Generate a metrics report with highlights and recommendations."""
    highlights = _generate_highlights(current_metrics, previous_metrics)
    recommendations = _generate_recommendations(current_metrics)

    period_label = "Weekly" if current_metrics.period.type == "weekly" else "Monthly"
    start = current_metrics.period.start_date.strftime("%b %d")
    end = current_metrics.period.end_date.strftime("%b %d, %Y")

    return MetricsReport(
        title=f"{period_label} Engineering Metrics Report: {start} - {end}",
        period=current_metrics.period,
        metrics=current_metrics,
        highlights=highlights,
        recommendations=recommendations,
        generated_at=datetime.now(),
    )


def _generate_highlights(
    metrics: DoraMetrics,
    previous: DoraMetrics | None = None,
) -> list[str]:
    """Generate key highlights from metrics."""
    highlights: list[str] = []
    overall = get_overall_rating(metrics)

    highlights.append(f"Overall DORA rating: {format_rating(overall)}")

    if metrics.deployment_frequency.rating.value == "elite":
        highlights.append(
            f"Deploying {metrics.deployment_frequency.deployments_per_day:.1f}x per day - Elite!"
        )

    if metrics.lead_time.rating.value in ("elite", "high"):
        highlights.append(
            f"Lead time of {metrics.lead_time.median_hours:.1f} hours is {format_rating(metrics.lead_time.rating)}"
        )

    if metrics.change_failure_rate.percentage < 5:
        highlights.append(
            f"Change failure rate of {metrics.change_failure_rate.percentage:.1f}% is excellent"
        )

    if metrics.mttr.incidents == 0:
        highlights.append("Zero incidents this period!")
    elif metrics.mttr.rating.value in ("elite", "high"):
        highlights.append(
            f"MTTR of {metrics.mttr.median_hours:.1f} hours shows strong incident response"
        )

    return highlights[:5]


def _generate_recommendations(metrics: DoraMetrics) -> list[str]:
    """Generate recommendations based on metrics."""
    recommendations: list[str] = []

    if metrics.deployment_frequency.rating.value in ("low", "medium"):
        recommendations.append("Consider implementing continuous deployment")
        recommendations.append("Break down large changes into smaller deployments")

    if metrics.lead_time.rating.value in ("low", "medium"):
        recommendations.append("Review PR review process - consider async reviews")
        recommendations.append("Implement automated testing to speed up reviews")

    if metrics.change_failure_rate.rating.value in ("low", "medium"):
        recommendations.append("Enhance automated testing, especially integration tests")
        recommendations.append("Consider feature flags for safer rollouts")

    if metrics.mttr.rating.value in ("low", "medium"):
        recommendations.append("Improve observability with better logging and monitoring")
        recommendations.append("Create runbooks for common incident scenarios")

    return recommendations[:5]


def format_report_markdown(report: MetricsReport) -> str:
    """Format report as Markdown."""
    metrics = report.metrics
    overall = get_overall_rating(metrics)

    def trend_arrow(change: float, inverse: bool = False) -> str:
        improved = change < 0 if inverse else change > 0
        if abs(change) < 5:
            return "→"
        return "↑" if improved else "↓"

    return f"""# {report.title}

## Overall Performance: {format_rating(overall)}

Generated: {report.generated_at.strftime("%B %d, %Y %I:%M %p")}

---

## DORA Metrics Summary

| Metric | Value | Rating |
|--------|-------|--------|
| Deployment Frequency | {metrics.deployment_frequency.deployments_per_day:.2f}/day | {format_rating(metrics.deployment_frequency.rating)} |
| Lead Time for Changes | {metrics.lead_time.median_hours:.1f} hours | {format_rating(metrics.lead_time.rating)} |
| Change Failure Rate | {metrics.change_failure_rate.percentage:.1f}% | {format_rating(metrics.change_failure_rate.rating)} |
| Mean Time to Recovery | {metrics.mttr.median_hours:.1f} hours | {format_rating(metrics.mttr.rating)} |

---

## Key Highlights

{chr(10).join(f"- {h}" for h in report.highlights)}

---

## Recommendations

{chr(10).join(f"{i+1}. {r}" for i, r in enumerate(report.recommendations))}

---

*Report generated by Engineering Metrics Dashboard*
"""


def format_report_slack(report: MetricsReport) -> dict:
    """Format report as Slack blocks."""
    metrics = report.metrics
    overall = get_overall_rating(metrics)

    emoji = {
        "elite": ":star2:",
        "high": ":white_check_mark:",
        "medium": ":warning:",
        "low": ":red_circle:",
    }

    return {
        "blocks": [
            {
                "type": "header",
                "text": {"type": "plain_text", "text": report.title},
            },
            {
                "type": "section",
                "text": {
                    "type": "mrkdwn",
                    "text": f"*Overall Rating:* {emoji[overall.value]} {format_rating(overall)}",
                },
            },
            {"type": "divider"},
            {
                "type": "section",
                "fields": [
                    {
                        "type": "mrkdwn",
                        "text": f"*Deployment Frequency*\n{metrics.deployment_frequency.deployments_per_day:.2f}/day {emoji[metrics.deployment_frequency.rating.value]}",
                    },
                    {
                        "type": "mrkdwn",
                        "text": f"*Lead Time*\n{metrics.lead_time.median_hours:.1f} hours {emoji[metrics.lead_time.rating.value]}",
                    },
                    {
                        "type": "mrkdwn",
                        "text": f"*Change Failure Rate*\n{metrics.change_failure_rate.percentage:.1f}% {emoji[metrics.change_failure_rate.rating.value]}",
                    },
                    {
                        "type": "mrkdwn",
                        "text": f"*MTTR*\n{metrics.mttr.median_hours:.1f} hours {emoji[metrics.mttr.rating.value]}",
                    },
                ],
            },
            {"type": "divider"},
            {
                "type": "section",
                "text": {
                    "type": "mrkdwn",
                    "text": f"*Key Highlights*\n{chr(10).join(f'• {h}' for h in report.highlights)}",
                },
            },
        ]
    }


async def send_slack_notification(report: MetricsReport, webhook_url: str) -> None:
    """Send report to Slack webhook."""
    payload = format_report_slack(report)

    async with httpx.AsyncClient() as client:
        response = await client.post(webhook_url, json=payload)
        response.raise_for_status()

    print("Slack notification sent successfully")
